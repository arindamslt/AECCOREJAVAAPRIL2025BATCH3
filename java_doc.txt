GITHUB LINK
======================================================================================
https://github.com/arindamslt/AECCOREJAVAAPRIL2025BATCH3.git
=======================================================================================
DATE:22.04.2025
============================================================================
FEATURES OF JAVA
=====================================================================
1.PLATFORM INDEPENDENT
2.OBJECT ORIENTED PROGRAMMING
3.MULTITHREADING
4.ROBUST
5.DISTRIBUTED
===================================================================================
FILE
====================
X.java===SOURCE CODE OF JAVA
javac X.java====JAVA COMPILER====CONVERTED INTO BYTE CODE=====X.class
java X==== X.class===GOES JVM(JAVA VIRTUAL MACHINE)====CONVERTED===O/P
JVM
=========================================
JAVA VIRTUAL MACHINE
IT IS AN ABSTRACT MACHINE WHOSE PURPOSE TO EXECUTE COMPILED JAVA CLASS
======================================================================
JDK===JAVA DEVELOPMENT TOOL KIT
JRE===JAVA RUNTIME ENVIRONMENT
JVM===JAVA VIRTUAL MACHINE
JIT===JUST IN TIME COMPILER
=======================================================================
OBJECT ORIENTED PROGRAMMING
==============================================================
CLASS====CLASS IS COLLECTION OF OBJECTS COMMON PROPERTIES AND BEHAVIOUR
     ======= DEAD TEMPLATE
OBJECT====REAL WORLD ENTITY
CHAIR TABLE BOOKSHELF   FURNITURE
=====================   =========
OBJECT                   CLASS
COMMON PROPERTEIS
===========================================
LENGTH===========
WIDTH        VARIABLE
HEIGHT==========
COMMON BEHAVIOUR
=========================
KEEPINGSOMETHING()=====METHOD  
====================================================
FEATURES OF OBJECT RIENTED PROGRAMMING
==================================================
1.ENCAPSULATION
================================================
CROCIN650
BINDING OF DATA AND METHOD TOGETHER
=======================================================

JAVA5
JAVA8
JAVA10
JAVA17
JAVA24
IDE===INTEGRATED DEVELOPMENT ENVIRONMENT
ECLIPSE,NETBEANS,INTELLIJI,STS
======================================================
java -version
======================================================
UML
==========================================
UNIFIED MODELLING LANGUAGE
==========================================
PURPOSE 
========================================
TO DRAW THE CLASS DIAGRAM.
============================================
2.PLOYMORPHISM
==============================================
POLY=====MANY
MORPHISM===FORMS
TYPES OF POLYMORPHISM
============================================
1.STATIC POLYMORPHISM
2.DYMANIC POLYMORPHISM
task(int a,int b)
task(int a,float b)
task(double a,double b)
task(5,6);
task(5,6.5);
task(6.6,9.6)
STATIC POLYMORPHISM IS CALLED METHOD OVERLOADDING
METHOD OVERLOADDING
=========================================
SAME METHOD NAME WITH DIFFERENT ARGUMENT PASSING IN THE SAME CLASS BODY IS SAME
methd1()
{
========================BODY
}
CONSTRUCTOR IS THE SAME NAME OF THE CLASS NAME.IT IS NOT EVEN VOID OR RETURN TYPE
BEACUSE IT RETURN A CLASS ITSELF.
PURPOSE
=============================================
1.CREATING THE OBJECT OF CLASS
2.AT THE TIME OF CREATING THE OBJECT INITIALIZE THE OBJECT
CLASS
=======================
MORE THAN ONE CONSTRUCTOR 
CONSTRUCTOR OVERLOADDING
======================================================================
3.INHERITANCE
====================================================
AQUIRING THE PROPERTY OF ONE CLASS INTO ANOTHER CLASS
================================================================
TYPES OF INHERITANCE
=================================================
1.SINGLE INHERITANCE
2.MULTILEVL INHERITANCE
3.HIERARCHICAL INHERITANCE
DYNAMIC POLYMORPHISM
===========================================
DYNAMIC POLYMORPHISM IS CALLED METHOD OVERRIDDING
===================================================
METHOD OVERRIDDING
====================================================
SAME METHOD NAME BOTH IN THE PARENT CLASS AND THE CHILD CLASS BUT
BODY IS DIFFERENT.
UTILITY OF SUPER
======================================================================
1.CALLING THE SUPER CLASS CONSTRUCTOR
2.CALLING THE SUPER CLASS METHOD WHICH IS HIDDEN IN SUBCLASS
====================================================================
DATE:23.04.2025
CONCRETE OR NORMAL METHOD
======================================================
public void show()
{
}
=========================================================================
4.ABSTRACTION
=============================================================
1.ABSTRACT METHOD
=======================================================
METHOD HAS NO BODY
public abstract void show();
2.ABSTRACT CLASS
==========================================
A CLASS CONSIDERED TO BE ABSTRACT IF THERE IS ATLEAST ONE METHOD IS ABSTRACT
abstract class Test
{
   public  abstract void show();
public void show1()
 {
  }
  
}
WE CAN'T CREATE OBJECT OF ABSTRACT CLASS
======================================================================================
5.DYNAMIC BINDING
========================================================================
IT DECIDES WHICH OBJECT WHICH METHOD TO BE CALLED AT THE RUNTIME.
MODIFIER
=========================================================================
MODIFIER TELLS HOW A MEMBER OF A CLASS IS BEING ACCESSED INTO ANOTHER CLASS
class Test
{
public int x=25;
}
class Test1
{

}
LIST OF MODIFIERS
===========================================
1.PRIVATE================
2.PROTECTED   ACCESS SPECIFIER
3.PUBLIC
4.DEFAULT================
5.STATIC
6.FINAL
7.ABSTRACT
8.SYNCHRONIZED
9.NATIVE
====================================================
PACKAGE
==================================================
COLLECTION OF SIMILLAR CLASSES ARE GROUP TOGETHER INTO A SINGLE UNIT CALLED PACKAGE
 PRIVATE MEMBERS ARE ACCESSABLE SAME CLASS ONLY.
 DEFAULT  MEMBERS ARE ACCESSABLE SAME CLASS AND IT'S CHILD CLASS IF THER ARE IN SAME PACKAGE
 PUBLIC AND PROTECTED MEMBERS ARE ACCESSABLE SAME AND IT'S CHILD CLASS EVEN IF
THEY ARE IN DIFFERENT PACKAGE.
==============================================================================
STATIC
================================================================================
IF WE DELCARE THE STATIC VARIABLE OR STATIC METHOD NO NEED TO CREATE A OBJECT
TO ACCESS THE METHOD AND VARIABLE
================================================================================
RESTRICTION
===============================================================================
STATIC MEMBER ARE ACCESSABLE WITHIN STATIC METHOD
static int x=25;
FINAL
===========================================
IF WE DECLARE A VARIABLE IS FINAL IT IS CONSTANT
IF WE DECALRE A METHOD IS FINAL IT CAN'T BE OVERRIDDEN
IF WE DECLARE A CLASS IS FINAL IT CAN'T BE EXTENDED
================================================================================
CLASS
=================================================================
public class
Super Class
Child Class
NESTED CLASS
===========================================================================
CLASS WITHIN CLASS IS CALLED NESTED CLASS
TYPES OF NESTED CLASS
=============================================
1.STATIC NESTED CLASS
2.NON STATIC NESTED CLASS CALLED INNER CLASS
================================================================================
class X====OUTER CLASS
{
============================
  class Y===INNER CLASS
   {

   }
}
class Test
{
   Inner inn=new Inner();//NOT POSSIBLE

IF I DELCLARE ANY VARIABLE IN OUTER CLASS IT IS ACCESSABLE TO THE INNER CLASS
IF WE DECLARE ANY VARIABLE IN INNER CLASS IT IS NOT ACCESSABLE IN OUTTER CLASS
WE CAN'T CREATE OBJECT OF INNER CLASS OUTSIDE THE OUTER CLASS.
THIS
=================================================================
THIS IS USED TO INVOKE THE CURRENT OBJECT
=====================================================================
int n;
void add()
{
  int n;
}
========================================================================================
INTERFACE
========================================================================================
INTERFACE IS A CONTRACT BEWTEEN THE IMPLEMENTED CLASS AND CLIENT CODE
IN INTERFACE ALL METHODS BY DEFAULT PUBLIC AND ABSTRACT
====================================================================================
CONSOLE INPUT OUPUT
==============================================================================
CONSOLE INPUT OUTPUT
=====================================================================
BUFFER READER CLASS====java.io.*;
SCANNER================java.util.*
=======================================================================
DATE:24.04.2025
==================================================================================
EXCEPTION HANDELLING
================================================================================
ERROR VS   EXCEPTION
==========================================================================
EXCEPTION IS AN EVENT WHICH OCCUR DURING THE EXECUTION PROGRAM.
IF WE HANDLE THE EXCEPTION THEN IT WILL PREVENT FROM ABNORMAL TERMINATION.
======================================================================================
ERROR===ERROR IS NOT RECOVERABLE
EXCEPTION IS RECOVERABLE
=================================================================================
HIERARCHY OF EXCEPTION
=====================================================================================
TYPES OF EXCEPTION
=============================================
1.UNCHECKED====RUNTIME EXCEPTION AND IT'S SUBCLASS
2.CHECKED======OTHER THAN RUNTIME EXCEPTION AND IT'S SUBCLASS
3.USER DEFINED EXCEPTION====IT IS CREATED BY DEVELOPER FOR THE PROJECT PURPOSE
                            WHICH IS NOT DEFINED BY JAVA
EXCEPTION HANDLE BY
============================================================
1.TRY
2.CATCH
3.FINALLY
4.THROW====GENERALLY USE TO THROW THE USER DEFINED EXCEPTION OBJECT
5.THROWS====IF WANT TO HANDLE THE EXCEPTION WITHOUT TRY AND CATCH THEN WE CAN
            USE THROWS CLAUSE ALONG WITH EXCEPTION CLASS NAME.
            BUT YOU HAVE TO HANDLE BOTH CALLER AND CALLE ENVIRONMENT.
=============================================================
UNCHECKED EXCEPTION
=============================================================
EXCEPTION HANDELLING MESSAGE
================================================
1.EXCEPTIONOBJECT.printstacktrace()=========>1.EXCEPTION CLASS NAME ALONG WITH THE PACKAGE
                                            2.EXCEPTION MESSAGE
                                           3.LINE NUMBER WHERE ERROR OCCURS
2.System.out.println(ExceptionObject);======1.EXCEPTION CLASS NAME ALONG WITH THE PACKAGE
                                              2.EXCEPTION MESSAGE
3.System.out.println(ExceptionObject.getMessage())====HERE EXCEPTION MESSAGE PRINT
===========================================================================================
FINALLY
===========================================================
WHETHER EXCEPTION OCCUR OR NOT IT WILLALWAYS BE EXECUTED
PURPOSE
==============================================
TO CLEAN UP THE TASK
=========================================================










